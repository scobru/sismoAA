{
  "language": "Solidity",
  "sources": {
    "contracts/SismoPKP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISismoVerifier {\r\n    function sismoVerify(\r\n        bytes memory sismoConnectResponse,\r\n        bytes16 appId,\r\n        bytes32 hash\r\n    ) external view returns (bytes memory, bytes memory);\r\n}\r\n\r\ncontract SismoPKP {\r\n    mapping(bytes16 => mapping(bytes32 => bytes)) private vaults;\r\n    mapping(bytes16 => mapping(bytes32 => bytes32)) private passKey;\r\n\r\n    bytes32[] public allVaultIds; // New array to keep track of all vault IDs\r\n\r\n    address public verifierContract;\r\n\r\n    constructor(address _verifierContract) {\r\n        verifierContract = _verifierContract;\r\n    }\r\n\r\n    function createPassKey(\r\n        bytes memory sismoConnectResponse,\r\n        bytes16 appId,\r\n        bytes32 onetimePass // pass in the signature\r\n    ) external {\r\n        (bytes memory vaultId, bytes memory signedMessage) = _verify(\r\n            sismoConnectResponse,\r\n            appId,\r\n            onetimePass\r\n        );\r\n\r\n        // random number 1 to 100\r\n        uint256 rand = uint256(\r\n            keccak256(abi.encodePacked(block.timestamp, block.prevrandao))\r\n        ) % 100000;\r\n\r\n        // create random 32 hash for passkey\r\n        bytes32 key = keccak256(\r\n            abi.encodePacked(\r\n                block.timestamp,\r\n                block.prevrandao,\r\n                rand,\r\n                signedMessage,\r\n                vaultId\r\n            )\r\n        );\r\n\r\n        passKey[appId][keccak256(vaultId)] = key;\r\n    }\r\n\r\n    function getPassKey(\r\n        bytes memory sismoConnectResponse,\r\n        bytes16 appId,\r\n        bytes32 onetimePass\r\n    ) external view returns (bytes32) {\r\n        (bytes memory vaultId, ) = _verify(\r\n            sismoConnectResponse,\r\n            appId,\r\n            onetimePass\r\n        );\r\n\r\n        return passKey[appId][keccak256(vaultId)];\r\n    }\r\n\r\n    function setWalletInfo(\r\n        bytes32 encryptedVaultId,\r\n        bytes16 appId,\r\n        bytes memory walletInfo\r\n    ) external {\r\n        require(\r\n            vaults[appId][encryptedVaultId].length == 0,\r\n            \"Wallet info already exists\"\r\n        );\r\n        vaults[appId][encryptedVaultId] = walletInfo;\r\n\r\n        allVaultIds.push(encryptedVaultId); // Add to list of all vault IDs\r\n    }\r\n\r\n    function getWalletInfo(\r\n        bytes32 encryptedVaultId,\r\n        bytes16 appId\r\n    ) external view returns (bytes memory) {\r\n        return vaults[appId][encryptedVaultId];\r\n    }\r\n\r\n    function _verify(\r\n        bytes memory sismoConnectResponse,\r\n        bytes16 appId,\r\n        bytes32 onetimePass\r\n    ) internal view returns (bytes memory, bytes memory) {\r\n        (bytes memory vaultId, bytes memory signedMessage) = ISismoVerifier(\r\n            verifierContract\r\n        ).sismoVerify(sismoConnectResponse, appId, onetimePass);\r\n\r\n        bytes32 _onetimePass = abi.decode(signedMessage, (bytes32));\r\n\r\n        require(_onetimePass == onetimePass, \"WRONG_ONETIMEPASS\");\r\n\r\n        return (vaultId, signedMessage);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}